1.ajax的使用:
    $.ajax("http://这里是你的请求地址/v1/img/captcha", {
        <!-- // get请求 -->
        method: "get", 
        <!-- // 当服务器发来html元素时，需要如此设置，使ajax进行html解析 -->
        dataType: 'html', 
        <!-- dataType: "json", // 希望服务器返回json格式数据，并使ajax进行json解析 -->
        <!--  允许跨域名储存和访问cookie -->
        xhrFields: {
        withCredentials: true // 允许跨域名储存和访问cookie
        }
    })
    <!-- // 处理ajax成功的回调 -->
    .done(function (data) { // 处理ajax成功的回调
        <!-- // 将获取到的html元素插入 -->
        $('#captcha').html(data) 
    })
    }
2.储存数据和填充数据
    $('.avatar').attr('src', avatar)
    // 用户名填充
    $('span').text(localStorage.name)
3.使用form表单初始化FormData对象方式上传文件
    <!-- 上传后，服务器端代码需要使用从查询参数名为img获取文件输入流对象，
        因为<input>中声明的是name="img"。 -->
    <!-- <form>标签添加enctype="multipart/form-data"属性。 -->
    <form id="uploadForm" enctype="multipart/form-data">
        <input id="file" type="file" name="img"/>
        <button id="upload" type="button">upload</button>
    </form>
    $.ajax({
        url: '/upload',
        type: 'POST',
        <!-- cache设置为false，上传文件不需要缓存。 -->
        cache: false,
        data: new FormData($('#uploadForm')[0]),
        <!-- processData设置为false。因为data值是FormData对象，不需要对数据做处理。 -->
        processData: false,
        <!-- contentType设置为false。因为是由<form>表单构造的FormData对象，
            且已经声明了属性enctype="multipart/form-data"，所以这里设置为false。 -->
        contentType: false
    }).done(function(res) {
    }).fail(function(res) {})
4.使用FormData对象添加字段方式上传文件
    <div id="uploadForm">
        <input id="file" type="file"/>
        <button id="upload" type="button">upload</button>
    </div>
    var formData = new FormData();
    <!-- append()的第二个参数应是文件对象，即$('#file')[0].files[0]。 -->
    formData.append('img', $('#file')[0].files[0]);
    $.ajax({
        url: '/upload',
        type: 'POST',
        cache: false,
        data: formData,
        processData: false,
        <!-- contentType也要设置为false。 -->
        contentType: false
    }).done(function(res) {
    }).fail(function(res) {})
    <!-- 从代码$('#file')[0].files[0]中可以看到一个<input type="file">标签
        能够上传多个文件，只需要在<input type="file">
        里添加multiple或multiple="multiple"属性。 -->
<!-- 5.事件绑定 $(selector).on(events[,selector][,data],handler); -->
        <!-- 注意selector不能是是动态一部添加的 -->
    // 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）
    // 第二个参数：selector, 执行事件的后代元素
    // 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用
    // 第四个参数：handler，事件处理函数
    // 表示给$(selector)绑定事件，当必须是它的内部元素span才能执行这个事件
    $(selector).on( "click",“span”, function() {});
    
    // 绑定多个事件
    // 表示给$(selector)匹配的元素绑定单击和鼠标进入事件
    $(selector).on(“click mouseenter”, function(){});
6.块级元素可用text-align:center居中
*********页面跳转window.location.href="你所要跳转的页面";必须用button type="button" 
     window.open('WriteArticle.html');不用
7.jq:     
    $(selector).css(“color”, “red”);
    $(selector).css({“color”: “red”, “font-size”: “30px”});
    $(selector).addClass(“liItem”);
    $(selector).removeClass(“liItem”);
    $(selector).removeClass(); 不指定参数，表示移除被选中元素的所有类
    <!-- img -->
    $(".nav-head").attr("src",img_url + user_data.avatar);
    <!-- 第4n个li设置 -->
    .hotel-line1>li:nth-child(4n) {
        margin-right: 0;
    }
    <!-- 在元素的最后一个子元素后面追加元素： -->
    append()（重点）
    <!-- // “自杀” 把自己（包括所有内部元素）从文档中删除掉 -->
    $(selector).remove();
    <!-- // 参数为：要移除的属性的名称 -->
    $(selector).removeAttr(“title”); 
    <!-- 参数为：要获取的属性的名称，该操作会返回指定属性对应的值 -->
    $(selector).attr(“title”);
8.JavaScript indexOf() 方法 
    indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。
    stringObject.indexOf(searchvalue,fromindex)
        searchvalue	必需。规定需检索的字符串值。
        fromindex	可选的整数参数。规定在字符串中开始检索的位置。
            它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。
    该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 searchvalue。
        开始检索的位置在字符串的 fromindex 处或字符串的开头（没有指定 fromindex 时）。
        如果找到一个 searchvalue，则返回 searchvalue 的第一次出现的位置。stringObject 中的字符位置是从 0 开始的。
    提示和注释
        注释：indexOf() 方法对大小写敏感！
        注释：如果要检索的字符串值没有出现，则该方法返回 -1。
9.JavaScript push() 方法
    push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。  
10.单行文本超出省略号
        overflow: hidden;
        text-overflow:ellipsis;
        white-space: nowrap;
    多行文本溢出显示省略号:
        <!-- display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 3;
        overflow: hidden; -->
        -webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：
        display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。
        -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。








微信绑定 背景变色：
    1.一个大的div1长宽整个页面的长宽 绝对定位 占据整个窗口 有个背景颜色 开始隐藏
    2.包含一个小的div2 里面放二维码
    3.点击绑定按钮，div1显示（div1就是整个页面） 点击任意地方 隐藏





登录公共部分：login-public.css
    页头  页尾

公共部分：other-public.css
    1.页头：header
        左侧：APIS|酒店项目
        右侧：
            登录 注册    ；  
            头像图片 姓名 下三角（我的订单 账户设置 退出登录） 我的订单
    2.页脚:footer

<!-- 注册->登录(忘记密码)->密码找回     -->
1.公共样式：login-public.css
    头部 底部 
登录：
    1.两个button 点击谁谁的背景颜色变为#5944C3 下方小三角出现 宽度变为225
头部:header
中心部分：main
底部：footer

注册：Register.html
登录：账号登录 短信快捷登录 :Login.html     
忘记密码、修改密码：验证身份 重置密码 ForgetPassword.html

<!-- 账户设置->绑定微信 -->
账户设置：AccountSet.html
<!-- 绑定微信：BindingWeChat.html -->


<!-- 首页/筛选->酒店详情->预定（->支付）->个人中心->查看/支付/取消预定/去评价 -->
首页（选城市 选时间）：index.html    main-top>header+ul>li*3  
筛选（行政区、商圈、地铁站、车站、景点）：Filter.html    
酒店详情：HotelDetails.html
预定：HotelReservation.html
支付：Payment.html
个人中心：（订单）PersonalCenter.html
评价：HotelEvaluate.html
查看：（订单状态。。。）SeeInformation.html
取消预定：CancelReservation.html


1.使用 .done() ， .fail() ， .always() 来代替传统回调
<!-- jqXHR.fail(function(jqXHR, textStatus, errorThrown) {});
一种可供选择的请求失败时调用的回调选项构造函数，.fail()方法取代了的过时的.error()方法。 -->
<!-- jqXHR.done(function(data, textStatus, jqXHR) {});
一种可供选择的请求成功时调用的回调选项构造函数，.done()方法取代了过时的.success()方法。 -->
<!-- jqXHR.always(function(data|jqXHR, textStatus, jqXHR|errorThrown) { });
一种可供选择的请求结束时调用的回调选项构造函数，.always()方法代替了过时的.complete()方法, -->
<!-- 当请求成功时，该函数的参数与.done()的参数一致；当请求失败时，该函数的参数与.fail()的参数一致。 -->



animate可以改变上下左右的宽高 
    <!-- // $(selector).animate(styles,options)
        // styles 必需。规定产生动画效果的 CSS 样式和值（同上）。
        //options 可选。规定动画的额外选项。
            可能的值：
            speed - 设置动画的速度
            easing - 规定要使用的 easing 函数
            callback - 规定动画完成之后要执行的函数
            step - 规定动画的每一步完成之后要执行的函数
            queue - 布尔值。指示是否在效果队列中放置动画。如果为 false，则动画将立即开始
            specialEasing - 来自 styles 参数的一个或多个 CSS 属性的映射，以及它们的对应 easing 函数 -->
    6.border-raduis:50%~100%都是圆
    7.setInterval
    <!-- setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。
        setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。
        提示： 1000 毫秒= 1 秒。
        提示： 如果你只想执行一次可以使用 setTimeout() 方法。
     -->
     1.用display显示时，点击显示闪一下就不见了：
     用了a标签，需要去除超链接的默认行为
         去除不了 换个方式 不用a标签                                         
dataset属性存取data-*自定义属性的值:
    这种方式通过访问一个元素的 dataset 属性来存取 data-* 自定义属性的值。
    这个 dataset 属性是HTML5 JavaScript API的一部分，用来返回一个所有选择元素 data- 属性的DOMStringMap对象。

    使用这种方法时，不是使用完整的属性名，如 data-uid 来存取数据，应该去掉data- 前缀。

    还有一点特别注意的是： data- 属性名如果包含了连字符，例如：data-date-of-birth ，
    连字符将被去掉，并转换为驼峰式的命名，前面的属性名转换后应该是： dateOfBirth 。

    <div id="user" data-id="1234567890" data-name="愚人码头" data-date-of-birth>码头</div>
    <script type="text/javascript">
    var el = document.querySelector('#user');
    console.log(el.id); // 'user'
    console.log(el.dataset);//一个DOMStringMap
    console.log(el.dataset.id); // '1234567890'
    console.log(el.dataset.name); // '愚人码头'
    console.log(el.dataset.dateOfBirth); // ''
    el.dataset.dateOfBirth = '1985-01-05'; // 设置data-date-of-birth的值.
    console.log('someDataAttr' in el.dataset);//false
    el.dataset.someDataAttr = 'mydata';
    console.log('someDataAttr' in el.dataset);//true
    </script>
    关于data-属性选择器:
    在实际开发时，您可能会发现它很有用，你可以根据自定义的 data- 属性选择相关的元素。例如使用querySelectorAll选择元素：

    javascript 代码:
    // 选择所有包含 'data-flowering' 属性的元素
    document . querySelectorAll ( '[data-flowering]' ) ;

    // 选择所有包含 'data-text-colour' 属性值为red的元素
    document . querySelectorAll ( '[data-text-colour="red"]' ) ;
<!-- /**
    * insertAdjacentHTML(position, text) 将指定的文本解析为HTML或XML，
    * 并将结果节点插入到DOM树中的指定位置。它不会重新解析它正在使用的元素，
    * 因此它不会破坏元素内的现有元素。
    * 这避免了额外的序列化步骤，使其比直接innerHTML操作更快。
    * 'afterbegin'插入元素内部的第一个子节点之前。
    *'beforebegin'元素自身的前面。
    *'beforeend'插入元素内部的最后一个子节点之后。
    *'afterend'元素自身的后面。
    */ -->

